Description
棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。棋盘用坐标表示，A点（0，0）、B点（n，m）（n，m为不超过15的整数），同样马的位置坐标是需要给出的。现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。
Input
一行四个数据，用空格分隔，分别表示B点的坐标和马的坐标。
Output
一个数据，表示所有的路径条数。
Sample
Input 
6 6 3 3
Output 
6


每个位置路径数图示：

1  1  1  1  1  1  1
1  2 -1  1 -1  1  2
1 -1  0  1  1 -1  2
1  1  1 -1  1  1  3
1 -1  1  1  0 -1  3
1  1 -1  1 -1  0  3
1  2  2  3  3  3  6




// 我们知道在到 (1, 1) 的前一步, 卒一定在 (0, 1) 和 (1, 0) 中的其中一个位置, 也就说从 (0, 0) 到 (1, 1) 的路径条数就是到 (0, 1) 和到 (1, 0) 的路径条数之和, 即到 (1,1) 点的路径有 2 条.
// 由此我们可以继续推出卒到 (n, m) 点的路径条数的递推式为: d[n][m] = d[n - 1][m] +d[n][m - 1].

//本题思路先找出马的控制点并赋值为-1，接着用for循环从第一行开始，计算到达每个点的路径数目，计算公式为d[n][m] = d[n - 1][m] +d[n][m - 1].
#include <iostream>
#include <algorithm>
using namespace std;
long long ma[30][30]={0}, n, m, x, y;
//马控制点相对于马所在位置的距离;
int b[9][2] = {{0, 0}, {-2, -1}, {-1, -2}, {-2, 1}, {-1, 2}, {2, 1}, {1, 2}, {2, -1}, {1, -2}};

int main() {
	std::ios::sync_with_stdio(false);
	cin >> n >> m >> x >> y;
	//加 1 使方格整体右下移一格是为了留出一个边界以使 ma[i - 1][j] 和 ma[i][j - 1] 都在数组范围内，如果对ma[1][0]进行操作，则ma[1][-1]超出边界；
  //注意加出来的这一行一列开始为0，后来为1
	x += 1;
	y += 1;
	n += 1;
	m += 1;
	//此时 A 点对应数组 ma[1][1];
	ma[1][1] = 1;
	//标记马的控制点;
	for (int i = 0; i < 9; i++) {
		ma[x + b[i][0]][y + b[i][1]] = -1;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			//当该点不是马的控制点时, 进行一下操作; 
            if (ma[i][j] != -1) {
				//判断ma[i][j]
                if (ma[i - 1][j] == -1 || ma[i][j - 1] == -1) { 
                    ma[i][j] += 1;//若马的上和下有马的控制点, 则加 1 以抵消ma[i-1][j]==-1或者ma[i][j-1]==-1；
                }
				//如果上边的if不成立，即ma[i - 1][j] ！= -1 && ma[i][j - 1] ！= -1，此时 ma[i][j] == 0；
                ma[i][j] +=ma[i - 1][j] + ma[i][j - 1];
            } 
        }
	}
	cout << ma[n][m] << endl;
	return 0;
} 
